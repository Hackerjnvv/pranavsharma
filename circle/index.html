<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Sandbox Simulator</title>
    <style>
        :root {
            --ui-bg: rgba(20, 20, 25, 0.85);
            --border-color: rgba(255, 255, 255, 0.2);
            --accent-color: #4af;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', 'Arial', sans-serif;
            color: white;
            user-select: none;
        }
        canvas { display: block; background-color: #08080A; }
        
        /* Main UI Layout */
        #ui-overlay {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column;
            justify-content: space-between;
        }
        .ui-header, .ui-footer {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .ui-footer {
            justify-content: center;
        }

        /* Stats & Info */
        #stats { font-size: 14px; opacity: 0.8; }
        #counter { font-size: 32px; font-weight: bold; text-shadow: 0 0 15px var(--accent-color); }

        /* Controls */
        #controls {
            pointer-events: auto;
            display: flex; flex-wrap: wrap; gap: 10px;
            background: var(--ui-bg); backdrop-filter: blur(5px);
            padding: 10px; border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        button {
            background: rgba(255,255,255,0.1); color: white;
            border: 1px solid rgba(255,255,255,0.5); border-radius: 5px;
            padding: 8px 15px; cursor: pointer; font-size: 14px;
            transition: background 0.2s, transform 0.1s;
        }
        button:hover { background: rgba(255,255,255,0.3); }
        button.active { background: var(--accent-color); color: #000; font-weight: bold; border-color: var(--accent-color); }

        /* Settings Panel */
        #settings-panel {
            position: absolute; top: 15px; right: 0;
            width: 300px;
            background: var(--ui-bg); backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-right: none;
            border-radius: 10px 0 0 10px;
            pointer-events: auto;
            transition: transform 0.3s ease-in-out;
            transform: translateX(0);
            z-index: 10;
        }
        #settings-panel.collapsed { transform: translateX(calc(100% - 35px)); }
        #settings-panel-content { padding: 15px; }
        #settings-toggle {
            position: absolute; left: 0; top: 0; bottom: 0;
            width: 35px;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer;
            writing-mode: vertical-rl; text-orientation: mixed;
            font-size: 16px; letter-spacing: 2px;
            background: rgba(0,0,0,0.2);
            border-right: 1px solid var(--border-color);
            border-radius: 10px 0 0 10px;
        }
        .setting { margin-bottom: 12px; }
        .setting label { display: block; margin-bottom: 5px; font-size: 14px; }
        .setting input[type="range"] { width: 100%; cursor: pointer; }
        .setting select { width: 100%; padding: 5px; background: #333; color: white; border: 1px solid #555; border-radius: 3px; }
        .setting-value { float: right; color: var(--accent-color); font-weight: bold; }
    </style>
</head>
<body>
    <div id="ui-overlay">
        <div class="ui-header">
            <div id="stats">Balls: 0 | FPS: 0 | Quadtree Chk: 0</div>
            <div id="counter">Escapes: 0</div>
        </div>
        <div class="ui-footer">
            <div id="controls">
                <button id="pauseBtn">Pause</button>
                <button id="resetBtn">Reset</button>
                <button id="modeBtn_launch" class="active">Mode: Launch Ball</button>
                <button id="modeBtn_gravity">Mode: Gravity Well</button>
                <button id="trailsBtn">Trails: ON</button>
                <button id="vectorsBtn">Vectors: OFF</button>
                <button id="gravityFieldBtn">Field: OFF</button>
            </div>
        </div>
    </div>
    
    <div id="settings-panel">
        <div id="settings-toggle">SETTINGS</div>
        <div id="settings-panel-content">
            <h4>Simulation</h4>
            <div class="setting">
                <label>Simulation Speed <span class="setting-value" id="simSpeedValue">1.0x</span></label>
                <input type="range" id="simSpeedSlider" min="0.1" max="3" step="0.1" value="1">
            </div>
            <h4>Physics</h4>
            <div class="setting">
                <label>Bounciness <span class="setting-value" id="bouncinessValue">0.85</span></label>
                <input type="range" id="bouncinessSlider" min="0.1" max="1.0" step="0.05" value="0.85">
            </div>
             <div class="setting">
                <label>Central Gravity <span class="setting-value" id="gravityValue">0.00</span></label>
                <input type="range" id="gravitySlider" min="0" max="0.2" step="0.005" value="0">
            </div>
            <h4>Ball Creation</h4>
             <div class="setting">
                <label>Ball Size <span class="setting-value" id="ballSizeValue">7</span></label>
                <input type="range" id="ballSizeSlider" min="2" max="20" step="1" value="7">
            </div>
             <div class="setting">
                <label>Launch Speed <span class="setting-value" id="launchSpeedValue">3.0</span></label>
                <input type="range"id="launchSpeedSlider" min="0.5" max="10" step="0.1" value="3">
            </div>
            <h4>Ring</h4>
            <div class="setting">
                <label>Ring Mode</label>
                <select id="ringModeSelect">
                    <option value="on" selected>On (with Gap)</option>
                    <option value="open">Open (C-Shape)</option>
                    <option value="off">Off (No Ring)</option>
                </select>
            </div>
            <div class="setting">
                <label>Gap Size <span class="setting-value" id="gapSizeValue">40Â°</span></label>
                <input type="range" id="gapSizeSlider" min="10" max="180" step="1" value="40">
            </div>
            <div class="setting">
                <label>Rotation Speed <span class="setting-value" id="rotationSpeedValue">1.0</span></label>
                <input type="range" id="rotationSpeedSlider" min="-5" max="5" step="0.1" value="1">
            </div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
    // --- Quadtree Implementation ---
    class Quadtree {
        constructor(bounds, capacity) {
            this.bounds = bounds; // { x, y, width, height }
            this.capacity = capacity;
            this.points = [];
            this.divided = false;
        }

        subdivide() {
            const { x, y, width, height } = this.bounds;
            const w = width / 2;
            const h = height / 2;
            this.northeast = new Quadtree(new Rectangle(x + w, y, w, h), this.capacity);
            this.northwest = new Quadtree(new Rectangle(x, y, w, h), this.capacity);
            this.southeast = new Quadtree(new Rectangle(x + w, y + h, w, h), this.capacity);
            this.southwest = new Quadtree(new Rectangle(x, y + h, w, h), this.capacity);
            this.divided = true;
        }

        insert(point) {
            if (!this.bounds.contains(point)) return false;
            if (this.points.length < this.capacity) {
                this.points.push(point);
                return true;
            }
            if (!this.divided) this.subdivide();
            return this.northeast.insert(point) || this.northwest.insert(point) ||
                   this.southeast.insert(point) || this.southwest.insert(point);
        }

        query(range, found = []) {
            if (!this.bounds.intersects(range)) return found;
            for (const p of this.points) {
                if (range.contains(p)) found.push(p);
            }
            if (this.divided) {
                this.northwest.query(range, found);
                this.northeast.query(range, found);
                this.southwest.query(range, found);
                this.southeast.query(range, found);
            }
            return found;
        }
    }
    
    // --- Bounding Box Helpers for Quadtree ---
    class Rectangle {
        constructor(x, y, w, h) { this.x = x; this.y = y; this.width = w; this.height = h; }
        contains(point) { return point.x >= this.x - point.radius && point.x <= this.x + this.width + point.radius && point.y >= this.y - point.radius && point.y <= this.y + this.height + point.radius; }
        intersects(range) { return !(range.x > this.x + this.width || range.x + range.width < this.x || range.y > this.y + this.height || range.y + range.height < this.y); }
    }

    // --- DOM Elements ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const statsElement = document.getElementById('stats');
    const counterElement = document.getElementById('counter');
    const settingsPanel = document.getElementById('settings-panel');
    const settingsToggle = document.getElementById('settings-toggle');

    // --- State ---
    const state = {
        center: { x: 0, y: 0 },
        ringRadius: 0,
        balls: [],
        gravityWells: [],
        quadtree: null,
        escapedCount: 0,
        collisionChecks: 0,
        lastTime: 0, fps: 0,
        isPaused: false,
        interactionMode: 'launch', // 'launch' or 'gravity'
        isDragging: false,
        dragStart: {}, dragEnd: {},
        // Toggles
        showTrails: true, showVectors: false, showGravityField: false,
        // Settings
        settings: {
            simSpeed: 1,
            bounciness: 0.85,
            centralGravity: 0,
            ballSize: 7,
            launchSpeed: 3,
            ringMode: 'on',
            gapAngle: Math.PI / 4.5,
            rotationSpeed: 0.0005
        }
    };
    
    // --- Main Functions ---
    function init() {
        resizeCanvas();
        initEventListeners();
        updateAllSettings();
        resetSimulation();
        animate();
    }

    function resetSimulation() {
        state.balls = [];
        state.gravityWells = [];
        state.escapedCount = 0;
        for (let i = 0; i < 10; i++) addBall(true);
        counterElement.textContent = `Escapes: 0`;
    }

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        state.center.x = canvas.width / 2;
        state.center.y = canvas.height / 2;
        state.ringRadius = Math.min(canvas.width, canvas.height) * 0.4;
    }

    // --- Event Listeners & Controls ---
    function initEventListeners() {
        window.addEventListener('resize', resizeCanvas);
        settingsToggle.onclick = () => settingsPanel.classList.toggle('collapsed');
        document.getElementById('pauseBtn').onclick = togglePause;
        document.getElementById('resetBtn').onclick = resetSimulation;
        document.getElementById('trailsBtn').onclick = () => { state.showTrails = !state.showTrails; updateButtons(); };
        document.getElementById('vectorsBtn').onclick = () => { state.showVectors = !state.showVectors; updateButtons(); };
        document.getElementById('gravityFieldBtn').onclick = () => { state.showGravityField = !state.showGravityField; updateButtons(); };
        document.getElementById('modeBtn_launch').onclick = () => setInteractionMode('launch');
        document.getElementById('modeBtn_gravity').onclick = () => setInteractionMode('gravity');
        
        // Settings Sliders & Selects
        document.querySelectorAll('#settings-panel input, #settings-panel select').forEach(el => {
            el.oninput = updateAllSettings;
        });

        // Canvas interaction
        canvas.oncontextmenu = e => e.preventDefault();
        canvas.onmousedown = e => {
            state.isDragging = true;
            state.dragStart = { x: e.clientX, y: e.clientY };
            state.dragEnd = { x: e.clientX, y: e.clientY };
            if (state.interactionMode === 'gravity') {
                 addGravityWell(e.clientX, e.clientY, e.button === 2 ? -1 : 1);
                 state.isDragging = false;
            }
        };
        canvas.onmousemove = e => { if (state.isDragging) state.dragEnd = { x: e.clientX, y: e.clientY }; };
        canvas.onmouseup = e => {
            if (state.isDragging && state.interactionMode === 'launch') {
                const dx = (e.clientX - state.dragStart.x) / 20;
                const dy = (e.clientY - state.dragStart.y) / 20;
                addBall(false, state.dragStart.x, state.dragStart.y, dx, dy);
            }
            state.isDragging = false;
        };
    }
    
    function updateAllSettings() {
        // Read values from UI and update state
        state.settings.simSpeed = parseFloat(document.getElementById('simSpeedSlider').value);
        state.settings.bounciness = parseFloat(document.getElementById('bouncinessSlider').value);
        state.settings.centralGravity = parseFloat(document.getElementById('gravitySlider').value);
        state.settings.ballSize = parseInt(document.getElementById('ballSizeSlider').value);
        state.settings.launchSpeed = parseFloat(document.getElementById('launchSpeedSlider').value);
        state.settings.ringMode = document.getElementById('ringModeSelect').value;
        state.settings.gapAngle = (Math.PI / 180) * parseFloat(document.getElementById('gapSizeSlider').value);
        state.settings.rotationSpeed = 0.0001 * parseFloat(document.getElementById('rotationSpeedSlider').value);

        // Update display values
        document.getElementById('simSpeedValue').textContent = `${state.settings.simSpeed.toFixed(1)}x`;
        document.getElementById('bouncinessValue').textContent = state.settings.bounciness.toFixed(2);
        document.getElementById('gravityValue').textContent = state.settings.centralGravity.toFixed(3);
        document.getElementById('ballSizeValue').textContent = state.settings.ballSize;
        document.getElementById('launchSpeedValue').textContent = state.settings.launchSpeed.toFixed(1);
        document.getElementById('gapSizeValue').textContent = `${(state.settings.gapAngle * 180 / Math.PI).toFixed(0)}Â°`;
        document.getElementById('rotationSpeedValue').textContent = (state.settings.rotationSpeed / 0.0001).toFixed(1);
    }

    function togglePause() {
        state.isPaused = !state.isPaused;
        if (!state.isPaused) state.lastTime = performance.now();
        updateButtons();
    }
    
    function setInteractionMode(mode) {
        state.interactionMode = mode;
        canvas.style.cursor = mode === 'launch' ? 'crosshair' : 'pointer';
        updateButtons();
    }

    function updateButtons() {
        document.getElementById('pauseBtn').textContent = state.isPaused ? 'Resume' : 'Pause';
        document.getElementById('trailsBtn').textContent = `Trails: ${state.showTrails ? 'ON' : 'OFF'}`;
        document.getElementById('vectorsBtn').textContent = `Vectors: ${state.showVectors ? 'ON' : 'OFF'}`;
        document.getElementById('gravityFieldBtn').textContent = `Field: ${state.showGravityField ? 'ON' : 'OFF'}`;
        document.getElementById('modeBtn_launch').classList.toggle('active', state.interactionMode === 'launch');
        document.getElementById('modeBtn_gravity').classList.toggle('active', state.interactionMode === 'gravity');
    }
    
    // --- Entity Management ---
    function addBall(atCenter = true, x, y, vx, vy) {
        const radius = state.settings.ballSize;
        const ball = {
            x: atCenter ? state.center.x : x,
            y: atCenter ? state.center.y : y,
            radius: radius,
            mass: Math.PI * radius * radius,
            color: `hsl(${Math.random() * 360}, 100%, 65%)`,
            isEscaping: false,
        };
        if (atCenter) {
            const angle = Math.random() * Math.PI * 2;
            ball.vx = Math.cos(angle) * state.settings.launchSpeed;
            ball.vy = Math.sin(angle) * state.settings.launchSpeed;
        } else {
            ball.vx = vx;
            ball.vy = vy;
        }
        state.balls.push(ball);
    }
    
    function addGravityWell(x, y, polarity = 1) {
        state.gravityWells.push({
            x, y,
            strength: polarity * 1500, // strength is proportional to mass
            radius: 50,
        });
    }

    // --- Update Loop ---
    function update(deltaTime) {
        const dt = deltaTime * state.settings.simSpeed;
        
        state.quadtree = new Quadtree(new Rectangle(0, 0, canvas.width, canvas.height), 4);
        state.balls.forEach(ball => state.quadtree.insert(ball));
        
        state.collisionChecks = 0;
        for (let i = state.balls.length - 1; i >= 0; i--) {
            const ball = state.balls[i];
            
            applyGravity(ball, dt);
            ball.x += ball.vx * dt;
            ball.y += ball.vy * dt;

            // *** LOGIC FIX STARTS HERE ***
            if (!ball.isEscaping) {
                // Ball-to-ball collisions are independent of the ring
                handleBallCollisions(ball);

                // Ring interaction logic
                if (state.settings.ringMode !== 'off') {
                    const dx = ball.x - state.center.x;
                    const dy = ball.y - state.center.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > state.ringRadius - ball.radius) {
                        if (isBallInGap(ball)) {
                            ball.isEscaping = true;
                            state.escapedCount++;
                            counterElement.textContent = `Escapes: ${state.escapedCount}`;
                            for(let j=0; j<2; j++) addBall(true);
                        } else {
                            handleWallCollision(ball, dist, dx, dy);
                        }
                    }
                }
            } else {
                if (ball.x < -100 || ball.x > canvas.width + 100 || ball.y < -100 || ball.y > canvas.height + 100) {
                    state.balls.splice(i, 1);
                }
            }
             // *** LOGIC FIX ENDS HERE ***
        }
    }
    
    function applyGravity(ball, dt) {
        if (state.settings.centralGravity > 0) {
            const dx = state.center.x - ball.x;
            const dy = state.center.y - ball.y;
            const distSq = dx * dx + dy * dy;
            if (distSq > 1) {
                const dist = Math.sqrt(distSq);
                const force = (state.settings.centralGravity / (distSq / 1000 + 1)) * dt;
                ball.vx += (dx / dist) * force;
                ball.vy += (dy / dist) * force;
            }
        }
        state.gravityWells.forEach(well => {
            const dx = well.x - ball.x;
            const dy = well.y - ball.y;
            const distSq = Math.max(100, dx * dx + dy * dy);
            const force = (well.strength / distSq) * dt;
            const dist = Math.sqrt(distSq);
            ball.vx += (dx / dist) * force;
            ball.vy += (dy / dist) * force;
        });
    }

    function handleBallCollisions(ball) {
        const range = new Rectangle(ball.x - ball.radius, ball.y - ball.radius, ball.radius * 2, ball.radius * 2);
        const others = state.quadtree.query(range);
        
        for (const other of others) {
            if (ball === other || other.isEscaping) continue;
            state.collisionChecks++;
            const dx = other.x - ball.x;
            const dy = other.y - ball.y;
            const distSq = dx * dx + dy * dy;
            const minRad = ball.radius + other.radius;
            if (distSq > 0 && distSq < minRad * minRad) {
                resolveCollision(ball, other);
            }
        }
    }

    // *** PHYSICS FIX STARTS HERE ***
    function resolveCollision(p1, p2) {
        const dx = p2.x - p1.x;
        const dy = p2.y - p1.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        // Normal vector
        const nx = dx / dist;
        const ny = dy / dist;

        // Relative velocity
        const dvx = p1.vx - p2.vx;
        const dvy = p1.vy - p2.vy;
        
        // Velocity along the normal
        const velAlongNormal = dvx * nx + dvy * ny;
        
        // Do not resolve if velocities are separating
        if (velAlongNormal < 0) return;

        const restitution = state.settings.bounciness;
        const invMass1 = 1 / p1.mass;
        const invMass2 = 1 / p2.mass;

        // Calculate impulse
        let impulse = -(1 + restitution) * velAlongNormal / (invMass1 + invMass2);
        
        // Apply impulse to velocities
        p1.vx += impulse * nx * invMass1;
        p1.vy += impulse * ny * invMass1;
        p2.vx -= impulse * nx * invMass2;
        p2.vy -= impulse * ny * invMass2;

        // Prevent overlap
        const overlap = (p1.radius + p2.radius - dist) / 2;
        p1.x -= overlap * nx;
        p1.y -= overlap * ny;
        p2.x += overlap * nx;
        p2.y += overlap * ny;
    }
    // *** PHYSICS FIX ENDS HERE ***

    function isBallInGap(ball) {
        if (state.settings.ringMode === 'open') return true;

        const dx = ball.x - state.center.x;
        const dy = ball.y - state.center.y;
        const angle = Math.atan2(dy, dx);
        const gapRotation = (performance.now() * state.settings.rotationSpeed) % (Math.PI * 2);
        let normalizedAngle = (angle - gapRotation + Math.PI * 2) % (Math.PI * 2);
        if (normalizedAngle > Math.PI) normalizedAngle -= Math.PI * 2;
        
        return Math.abs(normalizedAngle) < state.settings.gapAngle / 2;
    }

    function handleWallCollision(ball, dist, dx, dy) {
        const nx = dx / dist, ny = dy / dist;
        const dot = ball.vx * nx + ball.vy * ny;
        
        ball.vx -= 2 * dot * nx * state.settings.bounciness;
        ball.vy -= 2 * dot * ny * state.settings.bounciness;
        
        // Reposition ball to the edge to prevent sinking
        const correction = state.ringRadius - ball.radius - dist;
        ball.x += nx * correction;
        ball.y += ny * correction;
    }
    
    // --- Drawing ---
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (state.showTrails) {
            ctx.fillStyle = 'rgba(8, 8, 10, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        if (state.showGravityField) drawGravityField();
        drawGravityWells();
        if (state.settings.ringMode !== 'off') drawRing();
        
        state.balls.forEach(ball => drawBall(ball));
        if (state.isDragging && state.interactionMode === 'launch') drawTrajectoryPrediction();
    }
    
    function drawBall(ball) {
        ctx.fillStyle = ball.color;
        ctx.globalAlpha = ball.isEscaping ? 0.3 : 1;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;

        if (state.showVectors && !ball.isEscaping) {
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(ball.x, ball.y);
            ctx.lineTo(ball.x + ball.vx * 10, ball.y + ball.vy * 10);
            ctx.stroke();
        }
    }

    function drawRing() {
        const gapRotation = (performance.now() * state.settings.rotationSpeed) % (Math.PI * 2);
        const startAngle = gapRotation + state.settings.gapAngle / 2;
        const endAngle = gapRotation - state.settings.gapAngle / 2 + Math.PI * 2;
        
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 10;
        ctx.beginPath();
        if (state.settings.ringMode === 'open') {
             ctx.arc(state.center.x, state.center.y, state.ringRadius, Math.PI * 0.25, Math.PI * 1.75);
        } else {
             ctx.arc(state.center.x, state.center.y, state.ringRadius, startAngle, endAngle);
        }
        ctx.stroke();
    }
    
    function drawGravityWells() {
        state.gravityWells.forEach(well => {
            const isAttractive = well.strength > 0;
            const gradient = ctx.createRadialGradient(well.x, well.y, 0, well.x, well.y, well.radius);
            if (isAttractive) {
                gradient.addColorStop(0, 'rgba(100, 180, 255, 0.4)');
                gradient.addColorStop(1, 'rgba(100, 180, 255, 0)');
            } else {
                gradient.addColorStop(0, 'rgba(255, 100, 100, 0.4)');
                gradient.addColorStop(1, 'rgba(255, 100, 100, 0)');
            }
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(well.x, well.y, well.radius, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    function drawGravityField() {
        const gridSize = 40;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        for (let x = 0; x < canvas.width; x += gridSize) {
            for (let y = 0; y < canvas.height; y += gridSize) {
                let fx = 0, fy = 0;
                // Calculate net force vector
                state.gravityWells.forEach(well => {
                    const dx = well.x - x; const dy = well.y - y;
                    const distSq = Math.max(1000, dx * dx + dy * dy);
                    const force = well.strength / distSq;
                    const dist = Math.sqrt(distSq);
                    fx += (dx / dist) * force; fy += (dy / dist) * force;
                });
                const magnitude = Math.sqrt(fx * fx + fy * fy);
                const angle = Math.atan2(fy, fx);
                
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + Math.cos(angle) * magnitude * 200, y + Math.sin(angle) * magnitude * 200);
                ctx.stroke();
            }
        }
    }

    function drawTrajectoryPrediction() {
        let ghost = {
            x: state.dragStart.x,
            y: state.dragStart.y,
            vx: (state.dragEnd.x - state.dragStart.x) / 20,
            vy: (state.dragEnd.y - state.dragStart.y) / 20
        };

        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.setLineDash([2, 4]);
        ctx.beginPath();
        ctx.moveTo(ghost.x, ghost.y);

        for (let i = 0; i < 150; i++) {
            applyGravity(ghost, 1); // Simulate gravity for 1 step
            ghost.x += ghost.vx;
            ghost.y += ghost.vy;
            ctx.lineTo(ghost.x, ghost.y);
            if (ghost.x < 0 || ghost.x > canvas.width || ghost.y < 0 || ghost.y > canvas.height) break;
        }
        ctx.stroke();
        ctx.setLineDash([]);
    }

    // --- Main Loop ---
    function animate() {
        requestAnimationFrame(animate);
        
        const now = performance.now();
        let deltaTime = (now - (state.lastTime || now)) / 16.666;
        if (deltaTime > 3) deltaTime = 3; // cap delta time to prevent physics explosions
        state.lastTime = now;
        
        if (!state.isPaused) update(deltaTime);
        draw();
        
        // Stats
        state.fps = deltaTime > 0 ? Math.round(1 / (deltaTime * 16.666 / 1000)) : 0;
        statsElement.textContent = `Balls: ${state.balls.length} | FPS: ${state.fps} | Checks/F: ${state.collisionChecks}`;
    }

    init();
    </script>
</body>
</html>
